
# This defines global scenarios for controlling execution of the
# entire pipeline. Per job 'rules:' statements can then finese
# this on an individual basis if desired
workflow:
  rules:
    # For the main repo, prior to merging a patch series, CI is run
    # on the "staging" branch. The result gates whether the series
    # is then pushed to the default branch.
    #
    # For user forks, the default branch is typically unused or
    # otherwise just tracks the main repo default branch in an
    # adhoc manner. Work is typically done on feature branches
    # instead.
    #
    # In neither case do we wish to run CI pipelines for the
    # default branch
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_PROJECT_NAMESPACE == "berrange" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: never

    # For the main repo, tags represent official releases.
    # The branch associated with the release will have passed
    # a CI pipeline already
    #
    # For user forks, tags are often added by tools like
    # git-publish at the same time as pushing the branch.
    #
    # In neither case do we wish to run CI pipelines for tags
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_TAG'
      when: never

    # Run CI on any git pushes to remaining non-dfault branches
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH'
      when: always

    # Run CI on any regular scheduled pipelines (ie nightly builds)
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: always

    # Run CI if user invokes a pipeline using explicit REST API call
    - if: '$CI_PIPELINE_SOURCE == "api"'
      when: always

    # Run CI if user invokes a pipeline using Web UI
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: always

    # Don't run CI in any other scenario ($CI_PIPELINE_SOURCE values
    # covering: external, chat, webide, merge_request_event,
    # external_pull_request_event, parent_pipeline, trigger, or pipeline)
    - when: never


# This defines rules used to control individual job execution
.job_workflow:
  rules:
    # Skip any cirrus job if either repo or api token are missing
    - if: '$CIRRUS_VM_INSTANCE_TYPE && ($CIRRUS_GITHUB_REPO == null || $CIRRUS_API_TOKEN == null)'
      when: never

    # Any jobs marked as manual, never get automatically run in any scenario
    - if: '$QEMU_CI_MANUAL'
      when: manual
      allow_failure: true

    # Run all jobs for main repo staging branch
    - if: '$CI_PROJECT_NAMESPACE == "berrange" && $CI_COMMIT_BRANCH == "staging"'
      when: always

    # If pushing to a branch with name prefix 'ci-', then acceptance
    # tests if $QEMU_CI_AVOCADO_TESTING is set
    - if: '$CI_COMMIT_BRANCH =~ /^ci2-/ && $QEMU_CI_ACCEPTANCE && $QEMU_CI_AVOCADO_TESTING'
      when: always

    # If user requested CI using 'git push -o ci.variable="QEMU_CI=1"',
    # then acceptance tests if $QEMU_CI_AVOCADO_TESTING is set
    - if: '$QEMU_CI && $QEMU_CI_ACCEPTANCE && $QEMU_CI_AVOCADO_TESTING'
      when: always

    # Otherwise never run acceptance tests, but allow manual trigger
    - if: '$QEMU_CI && $QEMU_CI_ACCEPTANCE'
      when: manual
      allow_failure: true

    # If pushing to a branch with name prefix 'ci-', then run all jobs
    - if: '$CI_COMMIT_BRANCH =~ /^ci2-/'
      when: always

    # If user requested CI using 'git push -o ci.variable="QEMU_CI=1"',
    # then run all jobs
    - if: '$QEMU_CI'
      when: always

    # If user pushed in any other way, only default the small
    # number of default jobs needed to sanity check basic build
    - if: '$QEMU_CI_DEFAULT_JOB == "1"'
      when: always

    # Any other scenario, let the jobs be manually triggered.
    # Set to be non-fatal, so that pending manual jobs don't
    # affect overall pipeline status
    - when: manual
      allow_failure: true
